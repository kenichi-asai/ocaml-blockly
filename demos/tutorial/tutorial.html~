<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="tutorial.css">
  <title>ゲームプログラミング</title>
</head>
<body>
  
  <h1>ゲームプログラミング</h1>
  
  <h2></h2>
      ようこそ！ このページでは OCaml Blockly というブロックプログラミング言
語を使って、簡単なゲームを作成していきます。前提知識は一切、仮定しませ
ん。何も知らない状況から、ひとつひとつチュートリアルをクリアしていく
と、最後には、上からふってくるフルーツを下でキャッチするゲームを自分で
  作り上げることができます。楽しんで読み進めてみてください。
  
  <h3>0.メニューの使い方、四則演算</h3>
  <h4>OCaml Blockly でのプログラミングの流れ</h4>
  OCaml Blockly の画面は次の３つの部分からなります。
  <br>左側
  <br>ここのメニューから各種ブロックを選択します。
  <br>中央
  <br>ここがメインの作業をする場所です。 ここにブロックを組み上げていきます。
  <br>右側
  <br>作ったプログラムの保存、読み込み、実行を行います。

  <h4>プログラムの保存と読み込み</h4>
プログラムを保存したいときには、 ファイル名を指定して右側の保存ボタンを押す。 すると、ファイルが手元のパソコンにダウンロードされる。<br>
ダウンロードしたファイルは、この授業専用のディレクトリ（フォルダ）に 入れておくようにする。<br>
ダウンロードしたファイルを OCaml Blockly に読み込むには、 ファイルを選択して読み込みボタンを押す。<br>
  <h4>四則演算</h4>
  左の「四則演算」のメニューからブロックを選んで組み合わせる。 ブロックを取り出してから + の部分をクリックすると他の演算に変更できる。 ブロックはいくらでも入れ子にすることができる。<br><br>

  2+3のブロックを作ってみましょう。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 0">四則演算</button>
  
  <h3>1.変数、関数</h3>
  let ブロックを使うと 式に名前をつけることができる。 その名前は、そのブロックの「下」にくっついたブロックで使うことができる。 名前の部分をクリックすると、好きな名前に変更できる。<br>
  変数を使うときには、必ずその変数定義のブロックの下に くっついているところでなければならない。
<br>
  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 1">変数</button>
  <br><br>関数というのは、数学に出てくる関数のことで、f(x) = x + 1 などのこと。 関数は「何を受け取って来るか（引数（ひきすう）という）」と 「それを使って何を計算するか（本体）」からなる。 f(x) = x + 1 なら、引数は x で本体は x+1 である。<br>
  関数を定義するブロックにはふたつのコネクタがついている。 ひとつ目が引数用、ふたつ目が本体用である。 引数は、「パ」ボタン（パターン用のボタン）をクリックして、 そこから variable というのを選択して let ブロックにくっつける。 （引数の名前も変数と同様、自由に変更できる。）<br>

一方、本体はこれまでと同様、左側のメニューからブロックを選んでくっつける。 それに加えて、引数もそのままドラッグすると使うことができる。<br><br>

  関数を呼び出すには、関数名をドラッグして使う。 穴の部分には関数に渡す値を入れる。<br>
  関数を使うときにも、必ずその関数定義のブロックの下に くっついているところでなければならない。<br><br>
  関数を定義するブロックの歯車ボタンを押すと 複数の引数を持つ関数を定義することができる。 出てきた吹き出しの parameter というブロックを右側のところに加えてみよう。 すると、引数の数が増える。 これは f(x, y) = x + y のような２引数関数などを定義するのに使える。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 2">関数</button>
  <h3>2.画像</h3>
  ゲームは、ビッグバンにより始まる。 ビッグバンは「ゲーム用の定義」メニューの一番下にある big_bang というブロックを使う。 このブロックは「世界の初期値」を右側のコネクタに受け取るが、 今回は「世界」の情報は使わないので、単に 0 の数字をつなげておく。<br>
  この状態で実行すると、真っ白な画面が作られる。<br><br>
  このままだとゲーム画面の大きさは縦 300 ピクセル、横 300 ピクセルに 固定となる。 これを変更したい場合は、 big_bang ブロックの歯車ボタンを押し、 その中から ~width と ~height を右側にくっつける。 すると big_bang に縦横の大きさを指定する場所が現れる。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 3">big_bangの歯車ボタン</button>
  
  <br><br>ゲーム画面の大きさは、この先、プログラム中のあちこちで使うことが 予想される。 その際、数字ブロックをそのまま使うと、 後で画面の大きさを変更したくなったときに煩雑になる。 そこで、縦横の大きさを表す変数 width, height を let ブロックをつかって定義しておき、 それを使うようにする。 let ブロックは 前回にやったように「一般の変数と関数」メニューにあるが、 width, height を定義する let ブロックは 「ゲーム用の定義」メニューにもあるので、そちらを利用する方が簡単である。<br>
  このようにしておくと、後でゲーム画面の大きさを変更したくなったときには、 width, height の定義を変えるだけですむようになる。<br><br>

  ゲーム画面を作ることができたら、次にそこに風景 (scene) を表示したい。 これには、まず描画関数 draw を定義する。 この関数は「現在の世界の状態」を受け取ると、 それに従った風景 (scene) を返すような関数である。 このように、受け取ったものと返すもの（関数の型という）を 次のように表現する。 意味は、下に説明している通りだが、型を読めるようになると 楽に関数の受け取るもの、返すものを把握できるようになる。<br><br>

draw :: world -> scene<br><br>
１つ目の引数<br>
現在の世界の状態<br>
返すもの<br>
現在の世界の状態に従った風景<br><br>
ここで、「現在の世界の状態」というのはゲームの状態を一意に特定できるよ うな情報で、例えばりんごが落ちてくるゲームで、 そのりんごが現在 (132, 35) の位置にいるなら、 この座標が「現在の世界の状態」である。 この場合は、その位置にりんごが置かれたような風景を表示することになる。 このように描かれる風景は、現在の世界の状態によって変わるので、 ここではそれを関数として表現する。 つまり、現在の世界の状態 (world) を受け取ったら、 それに対応する風景を返す関数として表現する。 しかし、今日のところは「現在の世界の状態」に関わらず、 単に同じ風景を表示するので、この引数は無視することになる。<br>

  draw 関数は「ゲーム用の定義」メニューの中から選択する。 引数の部分には変数を入れて、名前を world としておく。 <br>

  draw 関数が返すものは「風景」である。 空の風景は、empty_scene という関数ブロックを使って作成する。 このブロックは「風景」メニューにある。<br><br>

empty-scene :: num * num -> scene<br><br>
１つ目の引数<br>
scene の横幅（ピクセル数）<br>
２つ目の引数<br>
scene の縦幅（ピクセル数）<br><br>
関数 empty-scene は２つのパラメタ（引数）を受け取る関数である。 scene の横幅，縦幅を受け取ったら、その大きさの空の scene を返す。<br><br>

  前の節で draw 関数を作ったが、 これは単に名前がたまたま draw であるような関数である。 特に「ゲーム画面を描画する関数」という特別の意味を持つわけではない。 この関数を「ゲーム画面を描画する関数」として使う場合には、 この関数を big_bang ブロックに「登録」する。<br><br>

draw 関数の登録は次のように行う。<br>
・まず、big_bang ブロックの歯車ボタンを押す。<br>
・その中の ~to_draw を右にくっつける。 すると draw 関数を登録する場所が現れる。<br>
・そこに draw 関数を「オプションキーを押しながら」 ドラッグする。<br>
「オプションキー」（Windows なら alt キー）を押しながらドラッグすると、 「穴のない関数ブロック」を生成することができる。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 4">draw関数の登録</button>

  <br><br>空の風景を出せるようになったら、いよいよそこに画像を載せてみよう。 画像を載せるには、次の place_image というブロックを使う。 これは「風景」メニューにある。<br><br>

place-image :: image * (num * num) * scene -> scene<br><br>
１つ目の引数<br>
配置したい画像<br>
２つ目の引数<br>
画像を置く場所の (x, y) 座標<br>
３つ目の引数<br>
画像が置かれる元の風景<br><br>
place_image ブロックは これらを受け取ると、３つ目の引数である風景の上に、 新たに１つ目の引数である画像を指定された場所に置いたような 新しい風景を返す。 これを繰り返して使うと、 好きなだけ画像を風景の上に置くことができるようになる。<br><br>

座標は「座標と世界の定義」メニューにある黄色いブロックを使う。 座標系は、x 座標は右向きだが、 y 座標は数学とは違って下向きである。 従って、原点 (0,0) は左上である。 また、置かれる座標 (x, y) は「置かれる画像の中央の位置」を示す。<br><br>

  あとは、画像の作り方が分かれば画像を画面に出すことができるようになる。<br><br>

  画像は「画像」メニューの中のものを使うことができる。 rectangle は四角の画像を作る。<br><br>

rectangle :: num * num * color -> image<br><br>
１つ目の引数<br>
四角の横の長さ<br>
２つ目の引数<br>
四角の縦の長さ<br>
３つ目の引数<br>
色<br><br>
rectangle は塗りつぶした四角となるが、 rectangle_outline を選ぶと外枠だけになる。 同様に circle, circle_outline は円の画像を作る。<br><br>

circle :: num * num * color -> image<br><br>
１つ目の引数<br>
円の半径の長さ<br>
２つ目の引数<br>
色<br><br>
しかし、実際のゲームを作る際にはこのような単純な図形ではなく、 もっときれいな画像を表示したくなる。 それには次のブロックを使う。<br><br>

read_image :: image * (num * num) * scene -> scene<br><br>
１つ目の引数<br>
読み込みたい画像の URL<br>
２つ目の引数<br>
画像の横幅<br>
３つ目の引数<br>
画像の縦幅<br><br>
このブロックを使うと、任意の URL に置かれた画像を 指定された大きさで読み込んだ画像を作ることができる。<br><br>

  <h3>3.画像の移動</h3>
  画像を動かすためには、次のふたつのことを行うことになる。<br>
・時間の経過（やいろいろなイベント）に応じて「世界」の情報を 更新する。<br>
・変更された世界を画面に反映させる。<br><br>

  画面に表示されている画像は、２種類に分けることができる。 ひとつは背景。 これは、ゲームが進んでも変化することのない部分のことである。 変化しない画像は、前回やった方法で表示すれば良い。 つまり draw 関数の中で（「世界」の状況に関わらず） 同じ位置に同じ画像をおけばよい。<br><br>

  もうひとつは、ゲームの進行に応じて変化するものである。 こちらは背景のように単純ではない。 時々刻々と変化する状況を画面に反映させる必要がある。 これは、一見するととても難しそうである。 しかし、次のふたつに分けて考えるとわかりやすくなる。<br>
・ゲームの状態はどのように変化していくのか。<br>
・ゲームの現在の状態を与えられたら、それをどのように表示するのか。<br>
重要な点は、ゲームの状態と画面に表示されている scene を分けて 考えるところである。 画面に表示されている scene はいろいろな画像で出来上がっており 複雑だが、実はその中で変化している部分はそれほど大きくはない。 そこの部分に注目すると、状態の変化を的確に捉えられるとともに、 それを画面に反映させるのも簡単になる。 この考え方で重要となるのは、ゲームの中で変化している部分は何かを 特定することである。 この情報のことを「世界」と呼ぶ。<br><br>

  「世界」というのは、変化するゲームの状態を定義するのに必要な 最低限の情報のことである。 例えば、今、画面にふたつの画像 A と B が表示されており、 そのうち A を時間の経過に応じて x 軸の正の方向に 一定の速度で動かしたいとしよう。 このような状況を再現するための必要最低限の情報とは何だろうか。 別の言い方をすると、どのような情報が与えられれば、一意に scene を 作ることができるだろうか。<br><br>

ふたつの画像のうち B は動かないので、B に関する情報は必要ない。 B をどこに配置するかは元から決まっているので、わざわざ与えられなくても B を配置することはできる。 では、A についてはどうだろうか。 A の位置はゲームの進行とともに変化する。 したがって、A の位置は与えてやらないと、scene を作ることができない。 このことから、「世界」の情報には A の位置を含めてやる必要があることが わかる。<br><br>

もう少し詳しく検討してみよう。 A の位置が必要なことがわかったが、A の位置はどのように定義できるだろうか。 A は x 軸の正の方向に動かしたいので、y 軸の値は固定である。 なので、A を配置するには x 軸の値さえわかれば良いことがわかる。<br><br>

以上の考察から、世界の情報としては A の x 座標の値（のみ）とすれば 良いことがわかる。<br>
【今回考える世界の定義】<br>
A の x 座標の値（整数で表現する）<br>
  big-bang の最初の引数は world であった。 実は、 ここで渡した world の値が draw の引数として 再描画時に渡されることになる。 したがって、big-bang の最初の引数に世界の情報を渡し、 draw 関数を引数 world にしたがって scene を 描くようにすれば、世界の状態に沿った scene を作ることができる。<br><br>
  
  draw 関数を、引数に渡される world を使って scene を 作るようにすると、そのときの世界の状況にそった scene を描くことが できる。 あとは、「世界」を更新できれば、画像を動かすことができるようになる。 「世界」を更新するには、まず on_tick 関数を定義する。 tick というのは、チクタクの英語 tick tock からきている。<br><br>

on_tick :: world -> world<br><br>
１つ目の引数<br>
現在の世界の状態<br>
返すもの<br>
1 tick 後の世界の状態<br><br>
on_tick 関数は、引数として現在の世界を受け取ったら、 1 tick 後の世界を返す。<br><br>

例えば、画像 A の x 座標を一回に 20 ピクセルだけ右に動かしたいとしよう。 現在の x 座標が world なら 次の x 座標は world+20 になる。 現在の x 座標は引数 world で与えられるので、 次のような関数を作れば良い。<br>
on_tick(world) = world + 20<br>
  この関数は、現在の状態として world（= A の x 座標）を 受け取ったら、次の状態（= A の新しい x 座標）を返す関数である。<br><br>

  on_tick 関数を作ったが、 これは単に名前がたまたま on_tick であるような関数である。 これを「1 tick ごとに世界を変化させる関数」として使う場合には、 draw 関数のときと同様にして、 この関数を big_bang ブロックに「登録」する必要がある。<br><br>

on_tick 関数の登録は次のように行う。<br>
・まず、big_bang ブロックの歯車ボタンを押す。<br>
・その中の ~on_tick を右にくっつける。 すると on_tick 関数を登録する場所が現れる。<br>
・そこに on_tick 関数を 「オプションキー（Windows なら alt キー）を押しながら」 ドラッグする。<br>
このようにすると、登録した関数が１秒に１回呼ばれ、 その結果にしたがって世界の情報が更新され、 それにしたがって画面が変化する。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 5">on_tick関数の登録</button>

  <br><br>何も設定しないと 1 tick は１秒だが、 次のようにすると 1 tick の時間の長さを変更することができる。<br>
・big_bang ブロックの歯車ボタンを押す。<br>
・その中の ~rate を右にくっつける。 すると rate を登録する場所が現れる。<br>
・そこに適当な数字を入れる。（単位はミリ秒。 その際、オプションキー（Windows なら alt キー）を押す必要はない。）<br><br>

  <h3>4.座標</h3>
  
  前回、画像を移動させる方法を学んだが、 まだ、一方向のみに移動するだけで、複雑な動きをさせることは できなかった。 これは、画像を動かすパラメタ（「世界」）が ひとつの値のみだったからである。 しかし、今後、例えばキー入力にしたがって画像を動かすことなどを 考えると、パラメタがひとつのみでは不十分である。 そこで、今回は座標を使って、世界を単にひとつの数字ではなく 座標値にすることを考える。<br><br>
【今回考える世界の定義】<br>
  （動かす画像の）座標<br><br>
  座標を使うには、「座標と世界の定義」メニューにある 座標ブロックを使う。 座標も、数字などと同様の普通のデータで、 名前をつけたり、関数に渡したりすることができる。<br><br>
  これまで、関数といえば f(x) = x+1 のように 引数には数字を受け取ることがほとんどであった。 今日は、受け取るものが数字ではなく座標であるような関数を扱う。 例えば、座標 (x, y) を受け取ったら、x 方向に 3 だけ移動した座標 (x+3, y) を返す関数は、f(x, y) = (x+3, y) と表現できる。<br><br>

座標を受け取る関数を作るときには、 関数の引数（パラメタ）を座標にしなくてはならない。 関数定義ブロックの「パ」ボタンを押すと 関数の引数を作ることができる。 これまでは、いつも変数 (variable) を選んでいたが、 今日は、座標 (pair) を選ぶ。 すると、関数の本体部分では、 受け取った座標のそれぞれの要素を使うことができるようになる。 座標のそれぞれの要素は普通の変数なので、ドラッグしたり、 名前を変更したりすることができる。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 6">座標</button>

  <br><br>座標の使い方がわかったので、いよいよ世界を座標にしてみよう。 ゲームは、<br>
・big_bang の最初の引数で世界の初期値を与え、<br>
・~on_tick に登録する関数で世界を更新し、<br>
・~to_draw に登録する関数で世界を scene に反映<br>
させるのだった。 したがって、これら３つの部分を変更して、座標を扱えるようにすればよい。<br><br>

  まず、世界の初期値を変更しよう。これまで、世界の初期値は数字だったが、 そこが座標になったので、例えば (50, 80) などに する必要がある。 これまで、世界の初期値は big_bang ブロックにそのまま 接続していたが、世界の初期値であることをより明確にするため、 それに initial_world という名前を与えることにしよう。<br><br>
  次に、draw 関数を変更しよう。 これまで、draw 関数は世界の情報として数字ひとつを受け取っていたが、 今回は世界の情報が座標になっている。 そこで、draw 関数の引数を座標にし、 この座標を使って風景を作るようにする。<br><br>
  次に、on-tick 関数を変更しよう。 draw 関数と同様に on-tick 関数も 世界の情報として座標を受け取る形になる。 それに加えて、on-tick 関数は「1 tick 後の世界の情報」を返すが、 この「1 tick 後の世界の情報」も（数字ひとつではなく）座標となる。 したがって、on-tick 関数が返すものも座標に変更する必要がある。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 7">世界を数字から座標へ</button>

  <br><br>例えば、右に進んでいた際、今のままだと画面からはみ出たら そのまま画像はいなくなってしまう。 右にはみ出た際、左側から現れるようにするには、 x 座標の値が width を超えたら、 x 座標の値から width を引いた値を新しい x 座標にしてやれば よい。 これは条件文（何回か後の授業でやります）を使っても可能だが、 同じことが四則演算の最後にある mod でも実現できる。 x mod y とすると、これで x を y で割った余りを計算する。 例えば 530 mod 500 は 30 である。<br><br>

  これを使うと、x 座標の値が width の値を超えたら、 x 座標の値を width で割った余りに変更してやることで 画像を左側に戻すことができる。 （左にはみ出た場合は 「『x 座標の値に width の値を加えたもの』を width で割った余り」に変更してやることで、 右から戻ってくるようになる。）<br><br>
  
  <h3>5,キー入力、条件文</h3>
  キー入力を受け付けるには、まず on_key 関数を作成する。 これは、「世界」と「押されたキー」を受け取ったら、 キーを押した後の「世界」を返す関数である。<br><br>

on_key :: world * string -> world<br><br>
１つ目の引数<br>
現在の世界の状態<br>
２つ目の引数<br>
起きたキーイベント<br>
返すもの<br>
キーイベントが起きた後の世界の状態<br><br>
例えば、キーが押されたら画像を少しだけ上に移動したいとしよう。 それには次のような関数を作れば良い。 （授業ではブロックで説明するので、このコードを理解する必要はない。）<br><br>

let on_key (x, y) key = (* 世界とキーを受け取ったら *)<br>
  (x, y - 10)           (* y 座標を減らした新しい世界を返す *)<br><br>

  この関数は、現在の状態として (x, y)（= 画像の座標）と key（= 押されたキー）を受け取ったら、 （上の場合は、どのキーが押されても） 次の状態（= 画像の新しい座標）を返す関数である。<br><br>

  上で作ったプログラムは、どのキーが押されても同じ動作をした。 しかし、実際には上矢印キーを押したら上がり、下矢印キーなら下がる、 といった動作を行いたい。 これをするためには、押されたキーによって場合分けをする必要がある。<br><br>

OCaml Blockly で条件によって場合分けをするには、if ブロックを使う。 if ブロックは「論理演算と条件文」メニューにある。 if ブロックには３つのブロックを接続する。<br><br>
１つ目のブロック<br>
場合分けの条件を表すブロック<br>
２つ目のブロック<br>
条件が成り立った場合に実行するブロック<br>
３つ目のブロック<br>
条件が成り立たなかった場合に実行するブロック<br>
このようなブロックを接続すると、まず条件部分が成り立つかどうかを調べ、 成り立ったら２つ目のブロックを、 成り立たなかったら３つ目のブロックを実行する。 （選ばれなかったブロックは実行することなく無視される。）<br><br>

条件部分には「論理演算と条件文」メニューにある各種の演算を使うことができる。 （三角のコネクタが、真偽値を表すコネクタである。）<br><br>

例えば、次の関数は、受け取った数の絶対値を返す。<br><br>

let abs x =<br>
  if x < 0 then 0 - x else x<br><br>

また、次の関数は、受け取ったふたつの数字の差が 2 以内だったら 「近い」、そうでなかったら「遠い」という文字列を返す関数である。<br><br>
	 
let sekkin x y =<br>
  if abs (x - y) <= 2 then "近い" else "遠い"<br><br>

	上に示した if ブロックは１回の条件分岐しかしなかったが、 if の歯車ボタンを押して else if then というブロックを 右側につけると、if ブロックのコネクタが増えて、 複数回の条件分岐を行うことができるようになる。 これで、まず最初の条件をチェックし、 それが成り立ったら、すぐ次のブロックを実行する。 成り立たなかったら次の条件をチェックし、 それが成り立ったら、すぐ次のブロックを実行する。 成り立たなかったら同様にして進み、 最後までどの条件も満たさなかったら、最後のブロックを実行する。<br><br>
		    
例えば、次の関数 f は、 受け取った数が負だったら 0 を返し、 0 以上 2 以下なら受け取った数をそのまま返し、 2 以上なら受け取った数の 2 倍から 2 を引いた数を返す。<br><br>

let f x =<br>
  if x < 0 then 0<br>
  else if x <=2 then x<br>
  else 2 * x - 2<br>
  
	<button onclick="window.location.href = 'dev_2.html' + '?num=' + 8">条件文</button>

	<br><br>押されたキーによって動作を変えるためには、 その前にまずキーを OCaml Blockly の中で表現しなくてはならない。 OCaml Blockly では、キーを文字列で表現する。<br><br>
アルファベット等：<br>
"A", "B" など。 これで A, B などのキーを示す。 （必ず大文字にする。小文字だと動かない。）<br>
矢印キー：<br>
"up", "down", "left", "right" （こちらは小文字で書く。）<br>
キーが同じかどうかは、= で判定ができる。<br><br>

以上を使うと、受け取ったキーに従って返ってくる世界を変えることができる。 典型的には、次のような格好になる。<br><br>

let on_key (x, y) key =          (* 現在の世界と押されたキーを受け取ったら *)<br>
                                 (* 場合分けをして、適切な次の世界を返す *)<br>
  if key = "up" then ...         (* 押されたキーが up だった場合 *)<br>
  else if key = "down" then ...  (* 押されたキーが down だった場合 *)<br>
  else ...                       (* それ以外のキーだった場合 *)<br><br>
  
  前の節で on_key 関数を作ったが、 これは単に名前がたまたま on_key であるような関数である。 これを「キーイベントごとに世界を変化させる関数」として使う場合には、 これまでと同様にして、 この関数を big_bang ブロックに「登録」する必要がある。<br><br>

on_key 関数の登録は次のように行う。<br>
・まず、big_bang ブロックの歯車ボタンを押す。<br>
・その中の ~on_key_press を右にくっつける。 すると on_key 関数を登録する場所が現れる。<br>
・そこに on_key 関数を 「オプションキー（Windows なら alt キー）を押しながら」 ドラッグする。<br>
このようにすると、登録した関数がキーを押すごとに呼ばれ、 その結果にしたがって世界の情報が更新され、 それにしたがって画面が変化する。 （~on_key_press の代わりに ~on_key_release に登録すると、 キーを「離す」ごとに関数が呼ばれるようになる。）<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 9">on_key関数の登録</button>
  <h3>6.真偽値、終了判定</h3>
  これまでに扱ってきたデータは、数字、文字列、画像、座標などであった。 今回は、これに加えて真偽値（英語では boolean という。 OCaml Blockly では bool と表現される） を扱う。 真偽値というのは、「真」か「偽」の値のいずれかで、 前者はあることが成り立っていること、後者は成り立っていないことを示す。 OCaml Blockly では、これらを true と false という ブロックで表す。 このブロックは「論理演算と条件文」メニューにある。<br><br>

  通常、true や false を直接、プログラムの中に書くこと はあまりない。 これらは、何かを判定した結果に使われる。 例えば、前回、条件文による場合分けを学習したが、 ここで使われる条件は、実は真偽値である。 例えば、x >= 0 というのは変数 x の値が 0 以上か どうかを判定する条件だが、実は x >= 0 という式自体は 実行すると true または false の値をとる真偽値である。 なので、例えば x が 3 であれば、この式の値は true に なるし、x が -3 であれば、この式の値は false になる。<br><br>

  我々が成り立つ、あるいは成り立たない、という話をするときには、 上のような単純なものに加えて、もっと複雑なことを話すことができる。 例えば「今日はよい天気だ」という文（これはその日の天気が定まると、 真または偽の値をとる）があったとき、 「今日はよい天気ではない」という否定の文章を考えることができる。 否定を OCaml Blockly で表すには not というブロックを使う。<br><br>

また、さらに「今日はいい天気で、かつ昨日は悪い天気だった」というように ふたつの（真偽値を表す）文章を結合することもある。 ふたつの真偽値の「かつ」を OCaml Blockly で表すには && というブロックを、 「または」を表すには || というブロックを使う。 （歯車ボタンを押すと、複数個の「かつ」「または」をとることもできる。）<br>

    <button onclick="window.location.href = 'dev_2.html' + '?num=' + 10">真偽値</button>

    <br><br>これまでに作ってきたプログラムは、一度、実行をはじめると止まることがな かった。 しかし、ゲームを作る上では、何らかの終了条件（例えば、飛行機がうまく着 陸できたとか、障害物にぶつかってしまったとか）を満たしたら、そこで ゲームを終了したい。 ゲームを終了させるには、 big_bang の ~stop_when に終了判定をする関数を指定する。 この関数は 「与えられた（現在の）世界が終了条件を満たしているかを判定する関数」 である。<br><br>

stop_when :: world -> bool<br><br>
１つ目の引数<br>
現在の世界の状態。<br>
返すもの<br>
受け取った世界が終了状態なら true、 そうでなければ false。<br><br>
この関数は、世界の状態が更新されるたびに呼ばれる。 その呼び出しの結果、true が返ってきたら、ゲームは終了する。<br><br>

	 今、考えている世界の情報は画像の座標である。 この座標を受け取ったら、それが終了条件を満たしているかを判定する関数を 登録してあげればゲームが終了するようになる。 例えば、前の節で作った not_flying は、 y-座標の値が height を超えたら、つまり画面の下を通り過ぎたら true になる。 したがって、この関数を登録すると、 画像が画面の一番下に到達した時点でゲームは終了する。<br>
	 
	 <button onclick="window.location.href = 'dev_2.html' + '?num=' + 11">stop_when関数の登録</button>
	 
	 <h3>7.複数の物体、レコード</h3>
	 数字や真偽値などは、ひとつのデータからできていたが、 座標はふたつのデータ、つまり x-座標の値と y-座標の値からできていた。 このように複数のデータから成り立つデータのことを レコード (record) あるいは構造体 (structure) と呼ぶ。<br><br>

一般に、レコードは複数のフィールドからできている。 各フィールドにはそれぞれデータが入っており、 それらをまとめたものがレコードである。<br><br>

皆が使っている OCaml Blockly では、 このレコードを自分で定義することができる。 レコードを定義するには、以下のような type ブロックを使う。 type ブロックは「座標と世界の定義」メニューにある。 type ブロックの歯車ボタンを押すと フィールドを増やすことができる。 また「型」ボタンを押すと、 各フィールドの型を指定するブロックが現れる。 「型」というのは、整数 (int) や文字列 (string)、 真偽値 (bool)、座標 (int * int) など、 データの種類を表すもののことである。<br><br>

type <定義するレコードの名前> = {<br>
  <フィールドの名前> : <その型>;<br>
  <フィールドの名前> : <その型>;<br>
  ...<br>
}<br><br>

このように宣言すると、 指定された型を持つフィールド達からなるレコードを使えるようになる。 OCaml Blockly では、レコードやフィールドは 必ず小文字で始まらなくてはならないという規則がある。 また、レコードは（型なので） 慣例で _t で終わる名前にすることが多い。<br><br>

例えば、名前と数学と英語の点数からなる学生のデータ seiseki_t を定義してみよう。<br><br>

type seiseki_t = {<br>
  name : string;  (* 名前 *)<br>
  math : int;     (* 数学の点数 *)<br>
  english : int;  (* 英語の点数 *)<br>
}<br><br>

      このようにすると、 name, math, english という ３つのフィールドからなるレコード型 seiseki_t が定義される。<br><br>

      レコードを宣言すると、そのブロックの下では レコードを具体的に作ることができる。 具体的なレコードを作るには、 （変数を作るときと同じように） レコードの名前のところをドラッグする。 ドラッグしたレコードは指定したフィールドを持っており、 そこには具体的な値を入れることができる。<br><br>

例えば、次の例は asai さん用の成績データを表すレコードである。<br><br>
{<br>
  namae = "asai";<br>
  math = 70;<br>
  english = 80;<br>
}<br><br>

      <button onclick="window.location.href = 'dev_2.html' + '?num=' + 12">レコード定義</button>

      <br><br>レコードは、他のデータと同じように関数に渡したり、 関数の結果として返したりすることができる。 レコードを受け取る場合は、関数の引数を （「パ」ボタンを押すと現れる）レコードのパターンにする。<br><br>

例えば、次の関数は seiseki_t 型のレコードを受け取ると、 その人の数学と英語の点数の平均を返す関数である。<br><br>

let heikin { name = n; math = m; english = e } =<br>
      (m + e) / 2<br><br>
      
      <button onclick="window.location.href = 'dev_2.html' + '?num=' + 13">レコードを受け取る関数</button>

      <br><br>ここからは、いよいよふたつの画像を動かすことを考えよう。 世界の情報には「ゲーム画面を作るために必要な最低限の情報」を含めるのであった。 動く画像がひとつであれば、 その画像の座標さえ与えられればゲーム画面を作れるので、 世界の情報はその画像の座標だけで良かった。 しかし、ふたつの画像を独立に動かそうと思えば、ふたつの座標が必要となる。<br><br>

そこで、今回考える座標はふたつの座標からなるレコードにする。 例えば、りんごとメロンのふたつを動かしたいなら、 次のようなレコードを宣言する。<br><br>

type world_t = {<br>
  apple : int * int;  (* りんごの座標 *)<br>
  melon : int * int;  (* メロンの座標 *)<br>
}<br><br>

座標の型は int * int となる。 int * int をブロックで作るときには、 「型」メニューでまず（ふたつの穴を持つ）* のブロックを使い、 そのふたつの穴に int のブロックを入れる。<br><br>

      【今回考える世界の定義】<br>
上で定義した（ふたつの座標からなる）world_t 型のレコード<br><br>
前回までは world の定義はひとつの座標だったが、今回は ふたつの座標からなるレコードになる。 したがって、これまで world を使っていた部分を 新しい定義に合うように変更する必要がある。 具体的には、 big_bang で与える世界の初期値、 to_draw, on_tick, on_key, stop_when で登録する関数をすべて変更する必要がある。 （前回までのプログラムを読み込む場合は） まずは、big_bang に登録している初期値と関数を すべて削除しておこう。 その上で、これらを順に作成していこう。<br><br>

      世界の初期値は、前回は画像ひとつの座標だったが、 今回は world_t 型のレコードである。 したがって<br><br>

let initial_world = {<br>
  apple = (100, 200);<br>
  melon = (300, 100);<br>
}<br><br>

      の形でなくてはならない。 ここで (100, 200), (300, 100) は ふたつの画像の初期座標である。<br><br>

      次に to_draw で登録する draw 関数を変更する。 draw 関数は次のような形をしていた。<br><br>

let draw world = (* 世界を受け取り *)<br>
  ...            (* それに応じた画面 (scene) を返す *)<br><br>

ここで、引数として受け取る world は これまではひとつの画像の座標だったが、 今回はふたつの座標（からなるレコード）である。 そこでまず、これを次のように変更する。<br><br>

let draw { apple = (ax, ay); melon = (mx, my) } = (* 世界を受け取り *)<br>
  ...                            (* それに応じた画面 (scene) を返す *)<br><br>

      ここで (ax, ay), (mx, my) は それぞれ現在の世界でのりんご、メロンの座標である。 したがって、この位置にそれぞれの画像を配置すれば良い。<br><br>

      draw 関数の引数部分をレコードにするには、 「パ」ボタンからレコードのパターンを選択する。 また、レコードのパターンの中には、座標のパターンを入れる。<br><br>
      
      時計の針が進むたびに呼ばれる関数は<br><br>

let on_tick world = (* 古い世界を受け取り *)<br>
  ...               (* 新しい世界を返す *)<br><br>

という形をしていた。 これまで世界はひとつの座標だったが、 今回からはふたつの座標からなるレコードである。 したがって、以下のような形の関数を作る必要がある。 受け取るものがレコードになっている。 また、返すものもレコードである。<br><br>

let on_tick { apple = (ax, ay); melon = (mx, my) } = (* 古い世界を受け取り *)<br>
  {                                      (* 新しい世界を返す。新しい世界は *)<br>
    apple = (..., ...);                  (* りんごの座標と *)<br>
    melon = (..., ...);                  (* メロンの座標からなる *)<br>
      }<br><br>

      それ以外の関数も同様である。 on_key で登録する関数は以下の形であった。<br><br>

let on_key world key = (* 古い世界と入力されたキーを受け取ったら *)<br>
  ...                  (* 新しい世界を返す *)<br><br>

前節にある on_tick と同様にして、 引数の world の部分はレコードにする。 返すもの（新しい世界）もレコードになる。<br><br>

また、stop_when で登録する関数は以下の形であった。<br><br>

let not_flying world = (* 世界の情報を受け取ったら *)<br>
  ...                  (* 停止すべきかを真偽値で返す *)<br><br>

      今回は、受け取る世界がふたつの座標からなるレコードなので、 引数 world の部分はレコードになる。 それを使って終了判定をすれば良い。<br>

      
</body>
</html>
