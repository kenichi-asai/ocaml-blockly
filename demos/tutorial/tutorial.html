<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="tutorial.css">
  <title>ゲームプログラミング</title>
</head>
<body>
  
  <h1>ゲームプログラミング</h1>
  
  <h2></h2>
  ようこそ！ このページでは <a href="dev_2_0.html">OCaml Blockly</a> というブロックプログラミング言語を使って、簡単なゲームを作成していきます。前提知識は一切、仮定しません。何も知らない状況から、ひとつひとつチュートリアルをクリアしていくと、最後には、<a href="#!" onclick= "window.open('canvas_2.html?num=0', 'newwindow', 'width=820, height=650')">上からふってくるフルーツを下でキャッチするゲーム</a>を自分で作り上げることができます。楽しんで読み進めてみてください。<br>
  
  <h3>0.メニューの使い方、四則演算</h3>
  <h4>OCaml Blockly でのプログラミングの流れ</h4>
  OCaml Blockly の画面は次の３つの部分からなります。
  <br><br><img src="blockly.png" width="600"><br>
  <br><font color="red">左側</font>
  <br>ここのメニューから各種ブロックを選択します。
  <br><font color="blue">中央</font>
  <br>ここがメインの作業をする場所です。 ここにブロックを組み上げていきます。
  <br><font color="green">右側</font>
  <br>作ったプログラムの保存、読み込み、実行を行います。

  <h4>プログラムの保存と読み込み</h4>
プログラムを保存したいときには、 ファイル名を指定して右側の保存ボタンを押します。すると、ファイルが手元のパソコンにダウンロードされます。<br>
ダウンロードしたファイルを OCaml Blockly に読み込むには、ファイルを選択して読み込みボタンを押します。<br>
  <h4>四則演算</h4>
  左の「四則演算」のメニューからブロックを選んで組み合わせます。 ブロックを取り出してから + の部分をクリックすると他の演算に変更できます。ブロックはいくらでも組み合わせて複数の演算することができます。<br><br><img src="arithmetic.jpg" width="500"><br><br>

  2+3のブロックを作ってみましょう。<br>

  <button id="t0" onclick="window.location.href = 'dev_2.html' + '?num=' + 0">四則演算</button>

  <br><br>練習問題<br>
  (5-2)*3のブロックを作ってみましょう。<br>
  <button id="0" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 0" style="background-color:lavender">練習問題を解く</button><br><br>
  
  <h3>1.変数、関数</h3>
  let ブロックを使うと 式に名前をつけることができます。その名前は、そのブロックの「下」にくっついたブロックで使うことができます。名前の部分をクリックすると、好きな名前に変更できます。<br>
  変数を使うときには、必ずその変数定義のブロックの下にくっついているところでなければなりません。
<br><br><img src="scope.jpg" width="400"><br><br>
<button id="t1" onclick="window.location.href = 'dev_2.html' + '?num=' + 1">変数</button>
<br><br>
<button id="t17" onclick="window.location.href = 'dev_2.html' + '?num=' + 17">変数の使用</button>

<br><br>練習問題<br>
widthという名前の値が800の変数と、heightという名前の値が500の変数を作りましょう。<br>
  <button id="1" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 1" style="background-color:lavender">練習問題を解く</button>

  <br><br>関数というのは、数学に出てくる関数のことで、f(x) = x + 1 などのことです。 関数は「何を受け取って来るか（引数（ひきすう）という）」と 「それを使って何を計算するか（本体）」からなります。 f(x) = x + 1 なら、引数は x で本体は x+1 です。<br><img src="f_x.jpg" width="400"><br><br>
  関数を定義するブロックにはふたつのコネクタがついています。 ひとつ目が引数用、ふたつ目が本体用です。 引数は、「パ」ボタン（パターン用のボタン）をクリックして、 そこから variable というのを選択して let ブロックにくっつけます。 （引数の名前も変数と同様、自由に変更できます。）<br>

一方、本体はこれまでと同様、左側のメニューからブロックを選んでくっつけます。 それに加えて、引数もそのままドラッグすると使うことができます。<br><br>

  関数を呼び出すには、関数名をドラッグして使います。 穴の部分には関数に渡す値を入れます。<br>
  関数を使うときにも、必ずその関数定義のブロックの下にくっついているところでなければなりません。<br><br>
  関数を定義するブロックの歯車ボタンを押すと 複数の引数を持つ関数を定義することができます。 出てきた吹き出しの parameter というブロックを右側のところに加えてみましょう。 すると、引数の数が増えます。 これは f(x, y) = x + y のような２引数関数などを定義するのに使えます。<br><br><img src="function.jpg" width="600"><br><br>

  <button id="t2" onclick="window.location.href = 'dev_2.html' + '?num=' + 2">関数</button>
<br><br>
<button id="t18" onclick="window.location.href = 'dev_2.html' + '?num=' + 18">関数の使用</button>
<br><br>
<button id="t19" onclick="window.location.href = 'dev_2.html' + '?num=' + 19">2引数関数に変更</button>
  <h3>2.画像</h3>
  ゲームは、ビッグバンにより始まります。 ビッグバンは「ゲーム用の定義」メニューの一番下にある big_bang というブロックを使います。 このブロックは「世界の初期値」を右側のコネクタに受け取りますが、「世界」の情報はこの先で使うので、ここでは単に 0 の数字をつなげておきます。<br>
  この状態で実行すると、真っ白な画面が作られます。<br><br>
  
  <button id="t14" onclick="window.location.href = 'dev_2.html' + '?num=' + 14">big_bang</button><br><br>
  
このままだとゲーム画面の大きさは縦 300 ピクセル、横 300 ピクセルに 固定となります。 これを変更したい場合は、big_bang ブロックの歯車ボタンを押し、その中から ~width と ~height を右側にくっつけます。すると big_bang に縦横の大きさを指定する場所が現れます。<br><br><img src="big_bang.jpg" width="600"><br><br>

ゲーム画面の大きさは、この先、プログラム中のあちこちで使うことが予想されます。 その際、数字ブロックをそのまま使うと、後で画面の大きさを変更したくなったときに煩雑になります。 そこで、縦横の大きさを表す変数 width, height を let ブロックをつかって定義しておき、 それを使うようにします。 widthとheightの定義の仕方は1.変数と関数のチュートリアル「変数定義」をみてください。 let ブロックは 前回にやったように「一般の変数と関数」メニューにありますが、 width, height を定義する let ブロックは 「ゲーム用の定義」メニューにもあるので、そちらを利用する方が簡単です。<br>
  このようにしておくと、後でゲーム画面の大きさを変更したくなったときには、width, height の定義を変えるだけですむようになります。<br>


  <button id="t3" onclick="window.location.href = 'dev_2.html' + '?num=' + 3">width, heightの指定</button>

  <br><br>
  練習問題<br>
  好きな大きさのゲーム画面を作ってみましょう。<br>
  <button id="2" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 2" style="background-color:lavender">練習問題を解く</button><br><br>
  
  <br><br>
  ゲーム画面を作ることができたら、次にそこに風景 (scene) を表示しましょう。 これには、まず描画関数 draw を定義します。 この関数は「現在の世界の状態」を受け取ると、それに従った風景 (scene) を返すような関数です。<br><br>
１つ目の引数<br>
&emsp;現在の世界の状態<br>
返すもの<br>
&emsp;現在の世界の状態に従った風景<br><br>
ここで、「現在の世界の状態」というのはゲームの状態を一意に特定できるような情報のことですが、これについては少し先で説明します。ここでは、引数の「現在の世界の状態」は無視して、世界の状況に関わらず同じ風景を表示します。<br>

  draw 関数は「ゲーム用の定義」メニューの中から選択します。 引数の部分には変数を入れて、名前を world としておきます。 <br>

  draw 関数が返すものは「風景」です。<ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景（何もかいていない風景）の上に画像を載せていきます。<br><ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景は、empty_scene という関数ブロックを使って作成します。 このブロックは「風景」メニューにあります。<br><br>

１つ目の引数<br>
&emsp;scene の横幅（ピクセル数）<br>
２つ目の引数<br>
&emsp;scene の縦幅（ピクセル数）<br><br>
  関数 empty-scene は２つのパラメタ（引数）を受け取る関数です。 scene の横幅，縦幅を受け取ったら、その大きさの<ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の scene を返します。<br><br><img src="empty_scene.jpg" width="400"><br><br>

  <ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景を返すdraw関数を作ってみましょう。<br><br>
  <button id="t15" onclick="window.location.href = 'dev_2.html' + '?num=' + 15">empty_scene</button><br><br>

  <ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景を表せるようになったら、いよいよそこに画像を載せてみましょう。 画像を載せるには、次の place_image というブロックを使います。これは「風景」メニューにあります。<br><br>

１つ目の引数<br>
&emsp;配置したい画像<br>
２つ目の引数<br>
&emsp;画像を置く場所の (x, y) 座標<br>
３つ目の引数<br>
&emsp;画像が置かれる元の風景<br><br>
place_image ブロックは これらを受け取ると、３つ目の引数である風景の上に、新たに１つ目の引数である画像を指定された場所に置いたような新しい風景を返します。 これを繰り返して使うと、好きなだけ画像を風景の上に置くことができるようになります。<br><br><img src="place_image.jpg" width="800"><br><br>

座標は「座標と世界の定義」メニューにある黄色いブロックを使います。 座標系は、x 座標は右向きですが、 y 座標は数学とは違って下向きです。 従って、原点 (0,0) は左上です。 また、置かれる座標 (x, y) は「置かれる画像の中央の位置」を示します。<br><br><img src="xy.jpg" width="300"><br><br>

  あとは、画像の作り方が分かれば画像を画面に出すことができるようになります。<br><br>

  画像は「画像」メニューの中のものを使うことができます。 rectangle は四角の画像を作ります。<br><br>

１つ目の引数<br>
&emsp;四角の横の長さ<br>
２つ目の引数<br>
&emsp;四角の縦の長さ<br>
３つ目の引数<br>
&emsp;色<br><br><img src="rectangle.jpg" width="500"><img src="rec_img.jpg" width="200"><br><br>

  <ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景に四角の画像を載せた風景を返すdraw関数を作ってみましょう。<br><br>
  <button id="t16" onclick="window.location.href = 'dev_2.html' + '?num=' + 16">四角の画像</button><br><br>

  今まで作った draw 関数は、単に名前がたまたま draw であるような関数です。 特に「ゲーム画面を描画する関数」という特別の意味を持つわけではありません。 この関数を「ゲーム画面を描画する関数」として使う場合には、この関数を big_bang ブロックに「登録」します。<br><br>
  <img src="draw1.jpg" width="700"><br><img src="draw2.jpg" width="700"><br><img src="draw3.jpg" width="1000"><br><br>

draw 関数の登録は次のように行います。<br>
・まず、big_bang ブロックの歯車ボタンを押します。<br>
・その中の ~to_draw を右にくっつけます。 すると draw 関数を登録する場所が現れます。<br>
・そこに draw 関数を「オプションキーを押しながら」 ドラッグします。<br>
「オプションキー」（Windows なら alt キー）を押しながらドラッグすると、「穴のない関数ブロック」を生成することができます。<br>

  <button id="t4" onclick="window.location.href = 'dev_2.html' + '?num=' + 4">draw関数の登録</button>

  <br><br>
  
  rectangle は塗りつぶした四角となりますが、rectangle_outline を選ぶと外枠だけになります。<br><br>

  練習問題<br>
  四角の位置や大きさ、色を変えてみましょう。<br>
  outlineにしてみましょう。<br>
  <button id="3" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 3" style="background-color:lavender">練習問題を解く</button><br><br>

  同様に circle, circle_outline は円の画像を作ります。<br><br>

１つ目の引数<br>
&emsp;円の半径の長さ<br>
２つ目の引数<br>
&emsp;色<br><img src="circle.jpg" width="400"><img src="cyc_img.jpg" width="150"><br><br>

  
  練習問題<br>
  横幅がwidth、縦幅がheightの<ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景に、半径が30、色がpinkの円を(400, 250)の位置に載せた風景を描画してみましょう。<br>
  <button id="4" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 4" style="background-color:lavender">練習問題を解く</button><br><br>

  
しかし、実際のゲームを作る際にはこのような単純な図形ではなく、もっときれいな画像を表示したくなります。それには次のブロックを使います。<br><br>

１つ目の引数<br>
&emsp;読み込みたい画像の URL<br>
２つ目の引数<br>
&emsp;画像の横幅<br>
３つ目の引数<br>
&emsp;画像の縦幅<br><br>
  このブロックを使うと、任意の URL に置かれた画像を指定された大きさで読み込んだ画像を作ることができます。<br><br><img src="read_image.jpg" width="600"><img src="bg_img.jpg" width="200"><br><br>
  
  練習問題<br>
  横幅がwidth、縦幅がheightの<ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景に、http://pllab.is.ocha.ac.jp/~asai/picture/images/background.pngの画像を横幅width、縦幅heightで(400, 250)の位置に載せた風景を描画してみましょう。<br><br>
  <button id="5" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 5" style="background-color:lavender">練習問題を解く</button><br><br>

  さらに、文字列を表示したい場合は次のブロックを使います。<br><br>

1つ目の引数<br>
&emsp;表示させたい文字列<br>
2つ目の引数<br>
&emsp;文字の大きさ<br>
3つ目の引数<br>  
&emsp;文字の色<br><br><img src="text.jpg" width="400"><img src="txt_img.jpg" width="200"><br><br>
  このブロックを使うと、任意の文字列を画面に表示できます。<br><br>

  練習問題<br>
  横幅がwidth、縦幅がheightの<ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景に、文字列"hello world"を大きさが20、色がgreenで(400, 250)の位置に載せた風景を描画してみましょう。<br>
  <button id="18" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 18" style="background-color:lavender">練習問題を解く</button><br><br><br>

   複数の画像を重ねて描画してみましょう。<br>
  <button id="t34" onclick="window.location.href = 'dev_2.html' + '?num=' + 34">複数の画像</button><br><br><br>
  
  練習問題<br>
  横幅がwidth、縦幅がheightの<ruby>空<rp>(</rp><rt>から</rt><rp>)</rp></ruby>の風景に、http://pllab.is.ocha.ac.jp/~asai/picture/images/background.pngの画像を横幅width、縦幅heightで(400, 250)の位置に載せた風景の上に、、http://pllab.is.ocha.ac.jp/~asai/picture/images/apple.png、http://pllab.is.ocha.ac.jp/~asai/picture/images/banana.png、http://pllab.is.ocha.ac.jp/~asai/picture/images/melon.pngを横幅と縦幅が100でそれぞれ(200, 50)、（400, 50)、(600, 50)の位置に、http://pllab.is.ocha.ac.jp/~asai/picture/images/bird.pngを横幅150、縦幅144で(400, 428)の位置に、文字列"0"を大きさ50、色がblackで(400, 458)の位置に載せた風景を描画してみましょう。<br><br>
  <button id="6" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 6" style="background-color:lavender">練習問題を解く</button><br><br>

  <h3>3.画像の移動</h3>

  画面に表示されている画像は、２種類に分けることができます。 ひとつは背景です。これは、ゲームが進んでも変化することのない部分のことです。変化しない画像は、前節でやった方法で表示すれば良いです。つまり draw 関数の中で（「世界」の状況に関わらず） 同じ位置に同じ画像をおきます。<br><br><img src="fighting.jpg" width="550"><br><br>

  もうひとつは、ゲームの進行に応じて変化するものです。 こちらは背景のように単純ではありません。 時々刻々と変化する状況を画面に反映させる必要があります。 これは、一見するととても難しそうです。 しかし、次のふたつに分けて考えるとわかりやすくなります。<br>
・ゲームの状態はどのように変化していくのか。<br>
・ゲームの現在の状態を与えられたら、それをどのように表示するのか。<br>
重要な点は、ゲームの状態と画面に表示されている scene を分けて 考えるところです。 画面に表示されている scene はいろいろな画像で出来上がっており複雑ですが、実はその中で変化している部分はそれほど大きくはありません。そこの部分に注目すると、状態の変化を的確に捉えられるとともに、それを画面に反映させるのも簡単になります。 この考え方で重要となるのは、ゲームの中で変化している部分は何かを特定することです。 この情報のことを「世界」と呼びます。<br><br>

  「世界」というのは、変化するゲームの状態を定義するのに必要な最低限の情報のことです。 例えば、今、画面にふたつの画像 A と B が表示されており、そのうち A を時間の経過に応じて y 軸の正の方向に 一定の速度で動かしたいとしましょう。 このような状況を再現するための必要最低限の情報とは何でしょうか。 別の言い方をすると、どのような情報が与えられれば、一意に scene を 作ることができるでしょうか。<br><br>

ふたつの画像のうち B は動かないので、B に関する情報は必要ありません。 B をどこに配置するかは元から決まっているので、わざわざ与えられなくても B を配置することはできます。 では、A についてはどうでしょうか。 A の位置はゲームの進行とともに変化します。 したがって、A の位置は与えてやらないと、scene を作ることができません。 このことから、「世界」の情報には A の位置を含めてやる必要があることがわかります。<br><br>

もう少し詳しく検討してみましょう。 A の位置が必要なことがわかりましたが、A の位置はどのように定義できるでしょうか。 A は y 軸の正の方向に動かしたいので、x 軸の値は固定です。 なので、A を配置するには y 軸の値さえわかれば良いことがわかります。<br><br><img src="ab.jpg" width="700"><br><br>

以上の考察から、世界の情報としては A の y 座標の値（のみ）とすれば 良いことがわかります。<br>
【ここで考える世界の定義】<br>
A の y 座標の値（整数で表現します）<br>
  big-bang の最初の引数は world でした。 実は、ここで渡した world の値が draw の引数として再描画時に渡されることになります。 したがって、big-bang の最初の引数に世界の情報を渡し、draw 関数を引数 world にしたがって scene を 描くようにすれば、世界の状態に沿った scene を作ることができます。<br><br>
  <button id="t20" onclick="window.location.href = 'dev_2.html' + '?num=' + 20">worldを使ったdraw関数</button><br><br>

  練習問題<br>
bing_bangブロックにつながっている初期値を色々な数に変えて実行してみましょう。<br><br>
  <button id="7" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 7" style="background-color:lavender">練習問題を解く</button><br><br>
  
  draw 関数を、引数に渡される world を使って scene を作るようにすると、そのときの世界の状況にそった scene を描くことができます。 あとは、「世界」を更新できれば、画像を動かすことができるようになります。「世界」を更新するには、まず on_tick 関数を定義します。 tick というのは、チクタクの英語 tick tock からきています。<br><br>

１つ目の引数<br>
&emsp;現在の世界の状態<br>
返すもの<br>
&emsp;1 tick 後の世界の状態<br><br>
on_tick 関数は、引数として現在の世界を受け取ったら、 1 tick 後の世界を返します。<br><br>

例えば、画像 A の y 座標を一回に 20 ピクセルだけ下に動かしたいとしましょう。 現在の y 座標が world なら 次の y 座標は world+20 になります。 現在の y 座標は引数 world で与えられるので、次のような関数を作れば良いです。<br>
on_tick(world) = world + 20<br>
    この関数は、現在の状態として world（= A の y 座標）を 受け取ったら、次の状態（= A の新しい y 座標）を返す関数です。<br><br>

    <button id="t21" onclick="window.location.href = 'dev_2.html' + '?num=' + 21">on_tick関数</button><br><br>

  ここで作ったon_tick 関数は、単に名前がたまたま on_tick であるような関数です。 これを「1 tick ごとに世界を変化させる関数」として使う場合には、 draw 関数のときと同様にして、 この関数を big_bang ブロックに「登録」する必要があります。<br><br>

on_tick 関数の登録は次のように行います。<br>
・まず、big_bang ブロックの歯車ボタンを押します。<br>
・その中の ~on_tick を右にくっつけます。 すると on_tick 関数を登録する場所が現れます。<br>
・そこに on_tick 関数を 「オプションキー（Windows なら alt キー）を押しながら」 ドラッグします。<br>
このようにすると、登録した関数が１秒に１回呼ばれ、その結果にしたがって世界の情報が更新され、 それにしたがって画面が変化します。<br>

  <button id="t5" onclick="window.location.href = 'dev_2.html' + '?num=' + 5">on_tick関数の登録</button>

  <br><br>何も設定しないと 1 tick は１秒ですが、次のようにすると 1 tick の時間の長さを変更することができます。<br>
・big_bang ブロックの歯車ボタンをします。<br>
・その中の ~rate を右にくっつけます。 すると rate を登録する場所が現れます。<br>
  ・そこに適当な数字を入れます。（単位はミリ秒です。 その際、オプションキー（Windows なら alt キー）を押す必要はありません。）<br><br>
  
  <button id="t22" onclick="window.location.href = 'dev_2.html' + '?num=' + 22">rateの指定</button><br><br>

  練習問題<br>
  rateを色々な数に変えてみましょう。<br><br>
  <button id="8" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 8" style="background-color:lavender">練習問題を解く</button><br><br>

  練習問題<br>
on_tick関数で返す値をworld+2、rateを100にした時と、on_tick関数で返す値をworld+20、rateを1000にした時の動きの違いを比べてみましょう。<br>
  <button id="9" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 9" style="background-color:lavender">練習問題を解く</button><br><br>

<!--
  <h3>4.座標</h3>
  
  前回、画像を移動させる方法を学んだが、 まだ、一方向のみに移動するだけで、複雑な動きをさせることは できなかった。 これは、画像を動かすパラメタ（「世界」）が ひとつの値のみだったからである。 しかし、今後、例えばキー入力にしたがって画像を動かすことなどを 考えると、パラメタがひとつのみでは不十分である。 そこで、今回は座標を使って、世界を単にひとつの数字ではなく 座標値にすることを考える。<br><br>
【今回考える世界の定義】<br>
  （動かす画像の）座標<br><br>
  座標を使うには、「座標と世界の定義」メニューにある 座標ブロックを使う。 座標も、数字などと同様の普通のデータで、 名前をつけたり、関数に渡したりすることができる。<br><br>
  これまで、関数といえば f(x) = x+1 のように 引数には数字を受け取ることがほとんどであった。 今日は、受け取るものが数字ではなく座標であるような関数を扱う。 例えば、座標 (x, y) を受け取ったら、x 方向に 3 だけ移動した座標 (x+3, y) を返す関数は、f(x, y) = (x+3, y) と表現できる。<br><br>

座標を受け取る関数を作るときには、 関数の引数（パラメタ）を座標にしなくてはならない。 関数定義ブロックの「パ」ボタンを押すと 関数の引数を作ることができる。 これまでは、いつも変数 (variable) を選んでいたが、 今日は、座標 (pair) を選ぶ。 すると、関数の本体部分では、 受け取った座標のそれぞれの要素を使うことができるようになる。 座標のそれぞれの要素は普通の変数なので、ドラッグしたり、 名前を変更したりすることができる。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 6">座標</button>

  <br><br>座標の使い方がわかったので、いよいよ世界を座標にしてみよう。 ゲームは、<br>
・big_bang の最初の引数で世界の初期値を与え、<br>
・~on_tick に登録する関数で世界を更新し、<br>
・~to_draw に登録する関数で世界を scene に反映<br>
させるのだった。 したがって、これら３つの部分を変更して、座標を扱えるようにすればよい。<br><br>

  まず、世界の初期値を変更しよう。これまで、世界の初期値は数字だったが、 そこが座標になったので、例えば (50, 80) などに する必要がある。 これまで、世界の初期値は big_bang ブロックにそのまま 接続していたが、世界の初期値であることをより明確にするため、 それに initial_world という名前を与えることにしよう。<br><br>
  次に、draw 関数を変更しよう。 これまで、draw 関数は世界の情報として数字ひとつを受け取っていたが、 今回は世界の情報が座標になっている。 そこで、draw 関数の引数を座標にし、 この座標を使って風景を作るようにする。<br><br>
  次に、on-tick 関数を変更しよう。 draw 関数と同様に on-tick 関数も 世界の情報として座標を受け取る形になる。 それに加えて、on-tick 関数は「1 tick 後の世界の情報」を返すが、 この「1 tick 後の世界の情報」も（数字ひとつではなく）座標となる。 したがって、on-tick 関数が返すものも座標に変更する必要がある。<br>

  <button onclick="window.location.href = 'dev_2.html' + '?num=' + 7">世界を数字から座標へ</button>
-->
  例えば、下に進んでいた際、今のままだと画面からはみ出たら そのまま画像はいなくなってしまいます。下にはみ出た際、上側から現れるようにするには、 y 座標の値が height を超えたら、 y 座標の値から height を引いた値を新しい y 座標にします。 これは条件文（少し先に出てきます）を使っても可能ですが、同じことが四則演算の最後にある mod でも実現できます。 x mod y とすると、これで x を y で割った余りを計算します。 例えば 530 mod 500 は 30 です。<br><br>

  これを使うと、y 座標の値が height の値を超えたら、 y 座標の値を height で割った余りに変更してやることで 画像を上側に戻すことができます。 （上にはみ出た場合は 「『y 座標の値に height の値を加えたもの』を height で割った余り」に変更してやることで、 下から戻ってくるようになるります。）<br><br><img src="mod.jpg" width="800"><br><br>
    <button id="t23" onclick="window.location.href = 'dev_2.html' + '?num=' + 23">mod</button><br><br>
  
   <h3>4.複数の物体、レコード</h3>
	 数字や真偽値などは、ひとつのデータからできていましたが、 座標はふたつのデータ、つまり x-座標の値と y-座標の値からできていました。 このように複数のデータから成り立つデータのことを レコード (record) あるいは構造体 (structure) と呼びます。<br><br>

一般に、レコードは複数のフィールドからできています。 各フィールドにはそれぞれデータが入っており、それらをまとめたものがレコードです。<br><br>

皆さんが使っている OCaml Blockly では、 このレコードを自分で定義することができます。 レコードを定義するには、以下のような type ブロックを使います。 type ブロックは「座標と世界の定義」メニューにあります。 type ブロックの歯車ボタンを押すと フィールドを増やすことができます。 また「型」ボタンを押すと、 各フィールドの型を指定するブロックが現れます。 「型」というのは、整数 (int) や文字列 (string)、 真偽値 (bool)、座標 (int * int) など、 データの種類を表すもののことです。<br><br>

  <code>
  <font size="4">
type <定義するレコードの名前> = {<br>
&emsp;  <フィールドの名前> : <その型>;<br>
&emsp;  <フィールドの名前> : <その型>;<br>
&emsp;  ...<br>
}<br><br>
  </font>
  </code><img src="type.jpg" width="500"><br><br>

このように宣言すると、 指定された型を持つフィールド達からなるレコードを使えるようになります。 OCaml Blockly では、レコードやフィールドは 必ず小文字で始まらなくてはならないという規則があります。 また、レコードは（型なので） 慣例で _t で終わる名前にすることが多いです。<br><br>

例えば、りんごとバナナのy座標からなるレコード型fruit_t を定義してみましょう。<br><br>
  <p style="display: flex; align-items: flex-start">
  <code>
  <font size="4">
type fruit_t = {<br>
&emsp;  apple : int;     (* りんごのy座標 *)<br>
&emsp;  banana : int;  (* バナナのy座標 *)<br>
}<br><br>
  </font>
  </code>
  <img src="fruit_t.png" width="300">
  </p>

  このようにすると、 apple, banana という 2つのフィールドからなるレコード型 fruit_t が定義されます。<br><br>

      レコードを宣言すると、そのブロックの下では レコードを具体的に作ることができます。 具体的なレコードを作るには、（変数を作るときと同じように）レコードの名前のところをドラッグします。 ドラッグしたレコードは指定したフィールドを持っており、そこには具体的な値を入れることができます。<br><br>

  例えば、次の例は りんごのy座標が0、バナナのy座標が50のレコードです。<br><br>

  <p style="display: flex; align-items: flex-start">
  <code>
  <font size="4">
{<br>
&emsp;  apple = 0;<br>
&emsp;  banana = 50;<br>
}<br><br>
  </font>
  </code>
  <img src="fruit.png" width="300">
  </p>

	     <button id="t11" onclick="window.location.href = 'dev_2.html' + '?num=' + 12">レコード定義</button><br><br>
	     <button id="t24" onclick="window.location.href = 'dev_2.html' + '?num=' + 24">レコードの作成</button>

      <br><br>レコードは、他のデータと同じように関数に渡したり、 関数の結果として返したりすることができます。 レコードを受け取る場合は、関数の引数を （「パ」ボタンを押すと現れます）レコードのパターンにします。<br><br>

例えば、次の関数は fruit_t 型のレコードを受け取ると、そのレコードの各フィールドにそれぞれ10を加えたレコードを返す関数です。<br><br>

    <p style="display: flex; align-items: flex-start">
  <code>
  <font size="4">
let add10 { apple: ay; banana: by } =<br>
&emsp;&emsp;      { apple = ay + 10; banana = by + 10 }<br><br>
  </font>
  </code>
  <img src="add10.png" width="350">
  </p>

      <button id="t13" onclick="window.location.href = 'dev_2.html' + '?num=' + 13">レコードを受け取る関数</button>

      <br><br>練習問題<br>
      増やす座標の大きさを変えてみましょう。<br>
  <button id="10" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 10" style="background-color:lavender">練習問題を解く</button>

      <br><br>ここからは、いよいよ複数の画像を動かすことを考えましょう。 世界の情報には「ゲーム画面を作るために必要な最低限の情報」を含めるのでした。 動く画像がひとつであれば、 その画像の座標さえ与えられればゲーム画面を作れるので、 世界の情報はその画像の座標だけで十分でした。 しかし、ふたつの画像を独立に動かそうと思えば、ふたつの座標が必要となります。<br><br>

      今回作るゲームは上から降ってくる3つのフルーツを下にいる鳥を左右に動かしてキャッチすると点数がもらえるというものです。このゲームの画面を作るために必要な最低限の情報が何かを考えましょう。<br>
      3つのフルーツはx座標は変化せず、それぞれy座標が動くので3つのy座標の値が必要です。<br>
      鳥は左右に移動するため、y座標が変化せずにx座標だけが変化するので、x座標の値が必要です。<br>
      フルーツをキャッチできると点数が増えるため、点数も表示させましょう。そのためには、点数もゲーム画面を作るのに必要になります。<br><img src="world.jpg" width="800"><br><br>

そこで、世界は5つの数字からなるレコードにします。 りんご、バナナ、メロンのy座標、鳥のx座標、点数の5つのフィールドからなるレコードは次のように宣言します。<br><br>

    <p style="display: flex; align-items: flex-start">
  <code>
  <font size="4">
type world_t = {<br>
&emsp;  apple : int;  (* りんごのy座標 *)<br>
&emsp;  banana : int; (* バナナのy座標 *)<br>
&emsp;  melon : int;  (* メロンのy座標 *)<br>
&emsp;  bird : int;   (* 鳥のx座標 *)<br>
&emsp;  score : int;  (* 点数 *)<br>
}<br><br>
  </font>
  </code>
  <img src="world_t.png" width="300">
  </p>

      練習問題<br>
      上のworld_tを定義してみましょう。<br><br>
  <button id="11" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 11" style="background-color:lavender">練習問題を解く</button><br><br>

      【ここで考える世界の定義】<br>
      5つの数字からなるレコード<br>
今までは world の定義はひとつの数字でしたが、ここでは 5つの数字からなるレコードになります。 したがって、これまで world を使っていた部分を 新しい定義に合うように変更する必要があります。 具体的には、 big_bang で与える世界の初期値、 to_draw, on_tick で登録する関数をすべて変更する必要があります。 （前回までのプログラムを読み込む場合は）まずは、big_bang に登録している初期値と関数をすべて削除しておきましょう。 その上で、これらを順に作成していきましょう。<br><br>

      世界の初期値は、前節は画像ひとつのy座標の値だったが、 ここでは world_t 型のレコードです。 これまで、世界の初期値は big_bang ブロックにそのまま 接続していましたが、世界の初期値であることをより明確にするため、 それに initial_world という名前を与えることにしましょう。<br>したがって<br><br>

    <p style="display: flex; align-items: flex-start">
  <code>
  <font size="4">
let initial_world = { <br>
&emsp;  apple = 0;<br>
&emsp;  banana = 0;<br>
&emsp;  melon = 0;<br>
&emsp;  bird = 400;<br>
&emsp;  score = 0;<br>
}<br><br>
  </code>
  </font>
  <img src="initial_world.png" width="350">
  </p>

      の形です。<br><br>

      練習問題<br>
      initial_worldを定義してみましょう。<br><br>
  <button id="12" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 12" style="background-color:lavender">練習問題を解く</button><br><br>

      次に to_draw で登録する draw 関数を変更します。 draw 関数は次のような形をしていました。<br><br>

    <p style="display: flex; align-items: flex-start">
    <code>
  <font size="4">
let draw world = (* 世界を受け取り *)<br>
&emsp;  ...            (* それに応じた画面 (scene) を返す *)<br><br>
  </font>
  </code>
  <img src="draw_x.png" width="300">
  </p>

ここで、引数として受け取る world は これまではひとつの画像のy座標でしたが、 今回は5つの数字（からなるレコード）です。 そこでまず、これを次のように変更します。<br><br>

    <p style="display: flex; align-items: flex-start">
      <code>
  <font size="4">
let draw { apple = ay; banana = by; melon = my; bird = x; score = score } = (* 世界を受け取り *)<br>
&emsp;  ...                            (* それに応じた画面 (scene) を返す *)<br><br>
  </font>
  </code>
  <img src="draw_record.png" width="350">
  </p>

      ここで ay, by, my は それぞれ現在の世界でのりんご、バナナ、メロンのy座標で、xは現在の世界での鳥のx座標です。 りんご、バナナ、メロン、鳥の座標は、それぞれ(200, ay)、(400, by)、(600, my)、(x, 428)です。したがって、この位置にそれぞれの画像を配置すれば良いです。<br>
      点数はそのままでは数字であるため、「文字列」メニューにあるstring_of_intブロックを使って文字列に変換したものを、大きさ50、色がblackで(x, 458)に表示します。<br><br>

      draw 関数の引数部分をレコードにするには、 「パ」ボタンからレコードのパターンを選択します。 <br><br>

      <button id="t25" onclick="window.location.href = 'dev_2.html' + '?num=' + 25">レコードを使うdraw関数</button><br><br>
      
	     <button id="t26" onclick="window.location.href = 'dev_2.html' + '?num=' + 26">得点の表示</button><br><br>

      練習問題<br>
      そらの背景の上にりんご、バナナ、メロン、鳥、点数を表示するdraw関数を作りましょう。<br>
      完成したら実行してみましょう。<br><br>
  <button id="13" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 13" style="background-color:lavender">練習問題を解く</button><br><br>
      
      時計の針が進むたびに呼ばれる関数は<br><br>

    <p style="display: flex; align-items: flex-start">
    <code>
  <font size="4">
let on_tick world = (* 古い世界を受け取り *)<br>
&emsp;  ...               (* 新しい世界を返す *)<br><br>
  </font>
  </code>
  <img src="ontick_x.png" width="300">
  </p>

という形をしていました。 これまで世界はひとつの画像のy座標でしたが、今回は5つの数字からなるレコードです。したがって、以下のような形の関数を作る必要があります。受け取るものがレコードになっています。また、返すものもレコードです。<br><br>

    <p style="display: flex; align-items: flex-start">
      <code>
  <font size="4">
let on_tick { apple = ay; banana = by; melon = my; bird = x; score = score } = (* 古い世界を受け取り *)<br>
&emsp;  {                                      (* 新しい世界を返す。新しい世界は *)<br>
&emsp;&emsp;    apple = ...;                  (* りんごのy座標と *)<br>
&emsp;&emsp;    banana = ...;                 (* バナナのy座標と *)<br>
&emsp;&emsp;    melon = ...;                  (* メロンのy座標と *)<br>
&emsp;&emsp;    bird = ...;                   (* 鳥のx座標と *)<br>
&emsp;&emsp;    score = ...;                  (* 点数からなる *)<br>
&emsp;      }<br><br>
  </font>
  </code>
  <img src="ontick_record.png" width="350">
  </p>

      りんご、バナナ、メロンは1tickごとにy座標がそれぞれ下に10、15、20移動します。鳥と点数は古い世界の値をそのまま返すようにします。<br><br>
      
      <button id="t27" onclick="window.location.href = 'dev_2.html' + '?num=' + 27">レコードを使うon_tick関数</button><br><br>

      練習問題<br>
      りんご、バナナ、メロンの座標を動かすon_tick関数を作りましょう。modを使って下にはみ出たら上から戻ってくるようにしましょう。<br>
      完成したら実行してみましょう。<br><br>
  <button id="14" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 14" style="background-color:lavender">練習問題を解く</button><br><br>
      
      <h3>5.キー入力、条件文</h3>
      前の節では、複数の物体が動くようになりました。この節では、そのうちの1つをキー操作によってユーザの思うように動かせるようにします。<br>
  キー入力を受け付けるには、まず on_key 関数を作成します。 これは、「世界」と「押されたキー」を受け取ったら、キーを押した後の「世界」を返す関数です。<br><br>

１つ目の引数<br>
&emsp;現在の世界の状態<br>
２つ目の引数<br>
&emsp;起きたキーイベント<br>
返すもの<br>
&emsp;キーイベントが起きた後の世界の状態<br><br>
例えば、キーが押されたら鳥の画像を少しだけ右に移動したいとしましょう。 それには、現在の「世界」と押されたキーを受け取ったら、新しい世界として鳥の座標だけが変化しているような世界を返します。 <br><br>

    <p style="display: flex; align-items: flex-start">
        <code>
  <font size="4">
let on_key { apple = ay; banana = by; melon = my; bird = x; score = score } key = (* 世界とキーを受け取ったら *)<br>
&emsp;  {          (* 鳥のx座標を増やした新しい世界を返す *)<br>
&emsp;&emsp;apple = ay;<br>
&emsp;&emsp;banana = by;<br>
&emsp;&emsp;melon = my;<br>
&emsp;&emsp;bird = x + 10;<br>
&emsp;&emsp;score = score <br>
&emsp;      }<br><br>
  </font>
  </code>
  <img src="onkey.png" width="350">
  </p>

	練習問題<br>
        on_tickブロックとbig_bangブロックの間にon_keyブロックを挿入しましょう。<br>on_keyブロックの引数はworld_t型なので、on_key関数の1つ目のコネクタにworld_t型のパラメタをつなぎましょう。<br><br>
  <button id="15" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 15" style="background-color:lavender">練習問題を解く</button><br><br>

					
	<button id="t28" onclick="window.location.href = 'dev_2.html' + '?num=' + 28">on_key関数</button><br><br>
  
  上で作った on_key 関数は、 名前がたまたま on_key であるような関数です。 これを「キーイベントごとに世界を変化させる関数」として使う場合には、 これまでと同様にして、 この関数を big_bang ブロックに「登録」する必要があります。<br><br>

on_key 関数の登録は次のように行います。<br>
・まず、big_bang ブロックの歯車ボタンを押します。<br>
・その中の ~on_key_press を右にくっつけます。すると on_key 関数を登録する場所が現れます。<br>
・そこに on_key 関数を 「オプションキー（Windows なら alt キー）を押しながら」 ドラッグします。<br>
このようにすると、登録した関数がキーを押すごとに呼ばれ、その結果にしたがって世界の情報が更新され、それにしたがって画面が変化します。（~on_key_press の代わりに ~on_key_release に登録すると、キーを「離す」ごとに関数が呼ばれるようになります。）<br>

	<button id="t9" onclick="window.location.href = 'dev_2.html' + '?num=' + 9">on_key関数の登録</button><br><br>					

  上で作ったプログラムは、どのキーが押されても同じ動作をしました。 しかし、実際には右矢印キーを押したら右に、左矢印キーなら左に移動する、といった動作を行いたいです。 これをするためには、押されたキーによって場合分けをする必要があります。<br><br>

OCaml Blockly で条件によって場合分けをするには、if ブロックを使います。 if ブロックは「論理演算と条件文」メニューにあります。if ブロックには３つのブロックを接続します。<br><br>
１つ目のブロック<br>
&emsp;場合分けの条件を表すブロック<br>
２つ目のブロック<br>
&emsp;条件が成り立った場合に実行するブロック<br>
３つ目のブロック<br>
&emsp;条件が成り立たなかった場合に実行するブロック<br>
このようなブロックを接続すると、まず条件部分が成り立つかどうかを調べ、 成り立ったら２つ目のブロックを、 成り立たなかったら３つ目のブロックを実行します。 （選ばれなかったブロックは実行することなく無視されます。）<br><br><img src="if.jpg" width="500"><br><br>

条件部分には「論理演算と条件文」メニューにある各種の演算を使うことができます。 （三角のコネクタが、真偽値を表すコネクタです。）<br><br>
  <!--
	<button onclick="window.location.href = 'dev_2.html' + '?num=' + 8">条件文</button> -->

	押されたキーによって動作を変えるためには、その前にまずキーを OCaml Blockly の中で表現しなくてはなりません。 OCaml Blockly では、キーを文字列で表現します。<br><br>
アルファベット等：<br>
&emsp;"A", "B" など。 これで A, B などのキーを示します。 （必ず大文字にします。小文字だと動きません。）<br>
矢印キー：<br>
&emsp;"up", "down", "left", "right" （こちらは小文字で書きます。）<br>
キーが同じかどうかは、= で判定ができます。<br><br>

<!--
以上を使うと、受け取ったキーに従って返ってくる世界を変えることができる。 典型的には、次のような格好になる。<br><br>

let on_key (x, y) key =          (* 現在の世界と押されたキーを受け取ったら *)<br>
                                 (* 場合分けをして、適切な次の世界を返す *)<br>
&emsp;  if key = "left" then ...         (* 押されたキーが left だった場合 *)<br>
&emsp;  else if key = "right" then ...  (* 押されたキーが right だった場合 *)<br>
	&emsp;  else ...                       (* それ以外のキーだった場合 *)<br><br>-->

	<button id="t29" onclick="window.location.href = 'dev_2.html' + '?num=' + 29">条件文</button>


	<br><br>上のプログラムでは右にしか行けませんでしたが、さらに左キーを押したら左にも行けるようにしてみましょう。それには、場合分けを複数に分岐させます。<br>上で使った if ブロックは１回の条件分岐しかありませんでしたが、 if の歯車ボタンを押して else if then というブロックを 右側につけると、if ブロックのコネクタが増えて、 複数回の条件分岐を行うことができるようになります。 これで、まず最初の条件をチェックし、それが成り立ったら、すぐ次のブロックを実行します。 成り立たなかったら次の条件をチェックし、それが成り立ったら、すぐ次のブロックを実行します。 成り立たなかったら同様にして進み、最後までどの条件も満たさなかったら、最後のブロックを実行します。<br><br><img src="elif.jpg" width="500"><br><br>

	<button id="t30" onclick="window.location.href = 'dev_2.html' + '?num=' + 30">複数条件の条件文</button><br><br>
	
  <h3>6.真偽値</h3>
  これまでに扱ってきたデータは、数字、文字列、画像、座標などでした。 今回は、これに加えて真偽値（英語では boolean という。 OCaml Blockly では bool と表現される） を扱います。 真偽値というのは、「真」か「偽」の値のいずれかで、 前者はあることが成り立っていること、後者は成り立っていないことを示します。 OCaml Blockly では、これらを true と false という ブロックでします。 このブロックは「論理演算と条件文」メニューにあります。<br><br>

  通常、true や false を直接、プログラムの中に書くことはあまりありません。 これらは、何かを判定した結果に使われます。 例えば、前節で条件文による場合分けを学習しましたが、 ここで使われる条件は、実は真偽値です。 例えば、key = "left" というのは変数 left の値が "left" か どうかを判定する条件ですが、実は key = "left" という式自体は実行すると true または false の値をとる真偽値です。 なので、例えば key が "left" であれば、この式の値は true になるし、key が "right" であれば、この式の値は false になります。<br><br>

  フルーツのy座標が455以上かどうかを判定する関数を作りましょう。
  <br><button id="t31" onclick="window.location.href = 'dev_2.html' + '?num=' + 31">真偽値</button><br><br>

  <!--
  我々が成り立つ、あるいは成り立たない、という話をするときには、 上のような単純なものに加えて、もっと複雑なことを話すことができる。 例えば「今日はよい天気だ」という文（これはその日の天気が定まると、 真または偽の値をとる）があったとき、 「今日はよい天気ではない」という否定の文章を考えることができる。 否定を OCaml Blockly で表すには not というブロックを使う。<br><br>

  また、さらに「今日はいい天気で、かつ昨日は悪い天気だった」というように ふたつの（真偽値を表す）文章を結合することもある。 ふたつの真偽値の「かつ」を OCaml Blockly で表すには && というブロックを、 「または」を表すには || というブロックを使う。 （歯車ボタンを押すと、複数個の「かつ」「または」をとることもできる。）<br>-->
  
  我々が成り立つ、あるいは成り立たない、という話をするときには、 上のような単純なものに加えて、もっと複雑なことを話すことができます。 例えば key = "left" という式（keyの値が定まると、 真または偽の値をとる）があったとき、key ≠ "left"という否定の式を考えることができます。 否定を OCaml Blockly で表すには not というブロックを使います。<br><br>

また、さらに「y ≧ 455、かつ y ≦ 465」というように ふたつの（真偽値を表す）式を結合することもあります。 ふたつの真偽値の「かつ」を OCaml Blockly で表すには && というブロックを、 「または」を表すには || というブロックを使います。（歯車ボタンを押すと、複数個の「かつ」「または」をとることもできます。）<br><br>

  フルーツのy座標が455以上かつ465以下かどうかを判定する関数を作りましょう。
  <br><button id="t32" onclick="window.location.href = 'dev_2.html' + '?num=' + 32">かつ、または</button><br><br>

  world_t型のレコードを受け取り、いずれかのフルーツのy座標が455以上かつ465以下の場合は、得点に10を足した点数を、そうでなければ得点をそのまま返す関数を作りましょう。
  <br><button id="t33" onclick="window.location.href = 'dev_2.html' + '?num=' + 33">複数のかつ、または</button><br><br>
  <!--
    <button onclick="window.location.href = 'dev_2.html' + '?num=' + 10">真偽値</button>-->

    <img src="catch1.jpg" width="700"><img src="catch2.jpg" width="450"><br><br>
	 
    練習問題<br>
    鳥がフルーツをキャッチできているかを判定する関数checkを作りましょう。
    checkは、フルーツのx座標とy座標と鳥のx座標を受け取ったら、フルーツのy座標が455以上かつ465以下で、かつフルーツと鳥のx座標の差が50以下の場合はtrueを返し、そうでない場合はfalseを返す関数にしましょう。<br><br>
    <button id="16" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 16" style="background-color:lavender">練習問題を解く</button><br><br>
    
    練習問題<br>
    鳥がフルーツをキャッチできていたらスコアに10を足す関数add_scoreを作りましょう。
    <br><br>
    <button id="19" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 19" style="background-color:lavender">練習問題を解く</button><br><br>

    練習問題<br>
    on_tiick関数で返すscoreを、上で作ったcheckを使って各フルーツをキャッチできているかを調べて、キャッチできている場合は10点足した点数になるように変更しましょう。<br><br>
  <button id="17" onclick="window.location.href = 'dev_2_2.html' + '?num=' + 17" style="background-color:lavender">練習問題を解く</button><br><br>

    <h3>7.まとめ</h3>

おめでとうございます。ゼロから始めて、ゲームが動くところまでやってくることができました。ここまで自力で終えることができた皆さんは、すでにプログラミングの基礎的な概念を習得しています。ブロックを使ったプログラミングだったので、お遊び感覚だったかもしれませんが、実は裏ではきちんとしたプログラムが作られています。是非、自信を持って、この先もいろいろなところでプログラミングに触れてみて欲しいと思います。<br><br>

    これでゲームを作るチュートリアルはすべて終了です。でも、せっかくですので、ここで作ったプログラムを自分なりに改良して、自分だけのゲームにしてみませんか。プログラミングの基礎をひととおり習得した皆さんであれば、十分にいろいろな面白いゲームを作ることができると思います。それを、是非、楽しんでください。<br><br>

    <button onclick= "window.open('canvas_2.html', 'newwindow', 'width=820, height=650')">
      どうやってゲームが動いているの？
    </button>
</body>
</html>
